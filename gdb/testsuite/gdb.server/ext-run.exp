# This testcase is part of GDB, the GNU debugger.

# Copyright 2007-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test running programs using extended-remote.

load_lib gdbserver-support.exp

standard_testfile server.c

require allow_gdbserver_tests

if {[build_executable $testfile.exp $testfile $srcfile debug] == -1} {
    return -1
}

# allow_xml_test must be called while gdb is not running.
set do_xml_test [allow_xml_test]

# This is used as an override function.
proc do_nothing {} { return 0 }

# Start an exetended-remote gdbserver, connect to it, and then use
# 'run' to start an inferior.
#
# If CLEAR_SYSROOT is true then the 'set sysroot' command is issued,
# clearing the sysroot, otherwise the sysroot is left unchanged.
#
# If SET_REMOTE_EXEC is true then the 'set remote-exec ...' command is
# issued to point GDB at the executable on the target (after copying
# the executable over).  Otherwise, we rely on GDB and gdbserver being
# able to see the same filesystem, remote exec-file is not set, and
# GDB will just use the path to the executable.
proc do_test { clear_sysroot set_remote_exec fetch_exec_and_args } {
    save_vars { ::GDBFLAGS } {
	if { $clear_sysroot } {
	    set ::GDBFLAGS "$::GDBFLAGS -ex \"set sysroot\""
	}

	clean_restart $::binfile
    }

    # Disable, or enable, use of the qDefaultExecAndArgs packet.
    gdb_test "set remote fetch-exec-and-args-packet ${fetch_exec_and_args}" \
	".*"

    # Make sure we're disconnected, in case we're testing with an
    # extended-remote board, therefore already connected.
    gdb_test "disconnect" ".*"

    gdbserver_start_extended

    gdb_test "show remote exec-file" \
	"The remote exec-file is \"\"\[^\r\n\]*" \
	"check remote exec-file is unset"

    if { $set_remote_exec } {
	set target_exec [gdbserver_download_current_prog]
	gdb_test_no_output "set remote exec-file $target_exec" \
	    "set remote exec-file"
    }

    gdb_breakpoint main
    gdb_test_multiple "run" "continue to main" {
	-re -wrap "Breakpoint.* main .*" {
	    pass $gdb_test_name
	}
	-re -wrap "Running the default executable on the remote target failed; try \"set remote exec-file\"." {

	    # If 'set remote exec-file' has been used then we should
	    # not get here.
	    gdb_assert {!$set_remote_exec} \
		"confirm remote exec-file is not set"

	    if {!$fetch_exec_and_args} {
		# We deliberately disabled GDB's ability to know that
		# the remote doesn't have a default executable set (by
		# disabling the qDefaultExecAndArgs packet).  We got
		# the result we expected, but the inferior is not
		# running, so we're done with this phase of testing.
		pass $gdb_test_name
		return
	    } else {
		# This means that the qMachineId packet is not supported,
		# and GDB could not tell if it is running on the same host
		# as gdbserver.  Confirm that qMachineId is showing as
		# disabled, and then move onto the next testing mode.
		gdb_test "show remote fetch-machine-id-packet" \
		    "Support for the 'qMachineId' packet on the current remote target is \"auto\", currently disabled\\." \
		    "confirm qMachineId packet is not supported"
		return
	    }
	}
    }

    if { [istarget *-*-linux*] } {
	# On Linux, gdbserver can also report the list of processes.
	# But only if xml support is compiled in.
	if { $::do_xml_test } {
	    # This is done in a way to avoid the timeout that can occur from
	    # applying .* regexp to large output.
	    gdb_test_sequence "info os processes" "get process list" \
		{ "pid +user +command" "1 +root +\[/a-z\]*(init|systemd)" }
	}
    }

    gdb_test "kill" "" "kill" "Kill the program being debugged. .y or n. " "y"

    gdb_load $::binfile
    gdb_test "monitor help" "The following monitor commands.*" \
        "load new file without any gdbserver inferior"

    gdb_test_no_output "monitor exit"
}

set clear_sysroot_modes { false }
set set_remote_exec_modes { true }
if {![is_remote target] && ![is_remote host]} {
    lappend set_remote_exec_modes false
    lappend clear_sysroot_modes true
}

# This override prevents GDB from automatically setting the 'remote
# exec-file' when using the extended-remote protocol.  If we want the
# exec-file set, then this test takes care of it.
with_override extended_gdbserver_load_last_file do_nothing {
    foreach_with_prefix clear_sysroot $clear_sysroot_modes {
	foreach_with_prefix set_remote_exec $set_remote_exec_modes {
	    foreach_with_prefix fetch_exec_and_args { on off } {
		do_test $clear_sysroot $set_remote_exec $fetch_exec_and_args
	    }
	}
    }
}
