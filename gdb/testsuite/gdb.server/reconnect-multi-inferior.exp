# This testcase is part of GDB, the GNU debugger.
#
# Copyright 2019 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This test checks GDB's handling of reconnecting to a remote target
# with multiple inferiors running.  The test should run with 'target
# remote' and with 'target extended-remote' using the
# 'native-gdbserver' and 'native-extended-gdbserver' boards
# respectively.
#
# The test makes use of an inferior that will fork several child
# processes.  By careful breakpoint placement GDB can control the
# creation of the child processes.
#
# The test runs in two modes:
#
#   1. Start a remote, connect GDB, then create several child
#      processes.  After each child process is created 'disconnect'
#      from the remote and then reconnect without restarting GDB.
#
#   2. Like the previous mode we create a remote target and connect
#      GDB, and again create several child processes.  After each
#      child is created we disconnect from the remote target, exit and
#      then restart GDB before finally reconnecting to the remote
#      target.
#
# In each case, after reconnecting to the remote target we confirm
# that GDB has detected the correct number of inferior processes.

load_lib gdbserver-support.exp

if { [skip_gdbserver_tests] } {
    verbose "skipping gdbserver tests"
    return -1
}

# We can only run this test if we know how to reconnect to a remote
# target.
if { [info proc gdb_reconnect] == "" } {
    return -1
}

# This test also makes use of 'detach-on-fork' which is not supported
# on all platforms.
if { ![istarget "*-*-linux*"] && ![istarget "*-*-openbsd*"] } then {
    continue
}

standard_testfile
if {[build_executable "failed to prepare" \
	 $testfile $srcfile debug] == -1} {
    return -1
}

# Run 'info inferiors' and check we have COUNT inferiors.  Use
# TESTNAME as a prefix for the tests.
proc do_info_inferiors {testname count} {
    global decimal
    global gdb_prompt

    set testname "${testname}, expecting ${count}"

    set last_inf_num 0
    set inf_count 0
    set seen_header 0
    gdb_test_multiple "info inferiors" $testname {
	-re "  Num\[ \t\]+Description\[ \t\]+Connection\[ \t\]+Executable\[^\r\n\]+\r\n" {
	    set seen_header 1
	    exp_continue
	}
	-re "^\[* \] ($decimal)\[ \t\]+<null>\[^\r\n\]+\r\n" {
	    exp_continue
	}
	-re "^\[* \] ($decimal)\[ \t\]+process $decimal\[ \t\]+$decimal \\\(\[^\)\]+\\\)\[ \t\]+\[^\r\n\]+\r\n" {
	    incr inf_count
	    set last_inf_num $expect_out(1,string)
	    exp_continue
	}
	-re "$gdb_prompt $" {
	    # Done, the pass/fail for this test is done using
	    # gdb_assert below.
	}
    }

    gdb_assert {$seen_header} "$testname: header line seen"
    gdb_assert {$inf_count == $count} "$testname: inferior count"
    gdb_assert {$last_inf_num != 0} "$testname: found last inferior number"

    return $last_inf_num
}

# Connect to gdbserver and check we have the expected number of
# inferiors, then continue the target until another inferior is
# created, at which point check that we have just one more inferior,
# before finally, disconnect from the remote.  INFERIOR_COUNT is the
# number of inferiors we expect to find when we first connect.
proc connect_and_check_inferiors { inferior_count } {

    # Reconnect to the existing target.
    gdb_reconnect

    # Now we've connected to the remote GDB knows which file we're
    # debugging, and we can place a breakpoint.
    gdb_breakpoint "breakpt"

    gdb_test "inferior 1" \
	"Switching to inferior 1 .*" \
	"Switching to inferior 1 before initial inferior check"

    # Count the inferiors and check we have the number we expect.
    do_info_inferiors \
	"info inferiors before we create a new one" \
	$inferior_count

    # Now continue until the 'breakpt' breakpoint, this should cause
    # another inferior to appear.
    gdb_continue_to_breakpoint "breakpt, creating a new inferior"

    # Count the inferiors and check we have the number we expect.
    set new_inf_num [expr $inferior_count + 1]
    set last_inf_num \
	[do_info_inferiors \
	     "info inferiors after we create a new one" \
	     $new_inf_num]

    # Switch to the latest inferior, and move it to the breakpoint.
    gdb_test "inferior $last_inf_num" \
	"Switching to inferior $last_inf_num .*" \
	"Switch to new inferior"
    gdb_continue_to_breakpoint "breakpt in new inferior"
    gdb_test "inferior 1" "Switching to inferior 1 .*"

    # When we reconnect to this target the inferior will be positioned
    # at the address of the 'breakpt' breakpoint, which GDB will
    # helpfully reinsert for us.
    #
    # The problem is that after reconnection all record of previous
    # interaction is (correctly) disgarded, so GDB doesn't know we
    # have already hit a breakpoint at 'breakpt' in inferior 1.
    #
    # Instead, when we try to continue, we immediately hit the
    # breakpoint at 'breakpt'.
    #
    # To avoid this we move the inferior on one instruction so we are
    # past the breakpoint location.
    gdb_test "si" ".*" "Nudge inferior 1 forward 1 instruction"

    # Finally, disconnect.
    gdb_test "disconnect" "Ending remote debugging\."
}

# Wrapper around steps needed to restart GDB in preparation for
# running one iteration of this test.
proc restart_gdb_for_test { } {
    global binfile srcdir subdir

    # We need to be very careful which procedures we use here to start
    # GDB as we don't want to start a new gdbserver, and we need to
    # consider both 'remote' and 'extended-remote' target types.
    #
    # Calling clean_restart is out, as for 'extended-remote' this
    # starts a new gdbserver.  This is done in an override of the
    # gdb_start proc, which is why we can't call that either.  Instead
    # we are left calling default_gdb_start.
    #
    # We deliverately don't start GDB with any binary file here,
    # instead we will rely on the remote target to tell us what we are
    # debugging.
    gdb_exit
    default_gdb_start
    gdb_reinitialize_dir $srcdir/$subdir

    # Ensure we track both parent and child after a fork.
    gdb_test_no_output "set detach-on-fork off"

    # Ensure we don't see anoying yes/no prompts.
    gdb_test_no_output "set confirm off"
}

# Start gdbserver for this test.  This proc sets two global variables
# GDBSERVER_GDBPORT and GDBSERVER_PROTOCOL, these are required when
# connecting to the gdbserver in CONNECT_AND_CHECK_INFERIORS.
proc start_gdbserver_for_test { } {
    global binfile srcdir subdir
    global gdbserver_gdbport gdbserver_protocol

    # We previously checked for the existence of gdb_reconnect proc.
    # If that proc exists, then the gdb_protocol parameter should
    # exist.
    set remote_protocol [target_info gdb_protocol]

    if { "${remote_protocol}" == "remote" } {
	# Start (or restart) gdbserver.
	set res [gdbserver_start "" $binfile]
	set gdbserver_protocol [lindex $res 0]
	set gdbserver_gdbport [lindex $res 1]
    } else {
	clean_restart ${binfile}

	if ![runto_main] then {
	    fail "can't run to main"
	    return 0
	}

	gdb_test "disconnect" "Ending remote debugging\."
	gdb_exit
    }
}

# Setting this before starting GDB will prevent the
# native-extended-remote board from spawning a gdbserver at the same
# time as starting GDB.  We will be restarting GDB many times
# throughout this test, but want to keep just one gdbserver around,
# which we will start ourselves.
set gdbserver_reconnect_p 1

# Run the tests.  For this outer look RESTART_P is true if we should
# restart GDB before each attempt to reconnect to the remove target.
# When RESTART_P is false we start GDB once and then connect /
# disconnect to the same target multiple times.
foreach_with_prefix restart_p { 0 1 } {

    # Start gdbserver now, this will run for this entire iteration of
    # the test.
    start_gdbserver_for_test

    # In the non-restarting version of the test we start GDB once here
    # and use the same GDB session to reconnect multiple times below.
    if { !$restart_p } {
	restart_gdb_for_test
    }

    for {set i 1} {$i <= 10} {incr i} {
	with_test_prefix "inferior $i" {

	    # In the restarting version of the test we restart GDB
	    # each time around this test loop, reconnecting to the
	    # remote in each fresh GDB.
	    if { $restart_p } {
		restart_gdb_for_test
	    }

	    connect_and_check_inferiors $i

	    if { !${restart_p} } {
		# Delete all breakpoints so that next time we call
		# CONNECT_AND_CHECK_INFERIORS we don't see a warning
		# about breakpoints already being set.
		gdb_test "delete breakpoints" ".*"
	    }
	}
    }

    # And we're done with the gdbserver now.
    close_gdbserver
}
