# Copyright 2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Setup a line table where:
#
# |      |      |      | Func | Func | Func |
# | Addr | Line | Stmt | main | foo  | bar  |
# |------|------|------|------|------|------|
# | 1    | 20   | Y    |      | X    |      |
# | 2    | 21   | Y    |      | X    |      |
# | 3    | 22   | N    |      | X    |      |
# | 4    | 32   | Y    | X    |      |      |
# | 5    | 33   | Y    | X    |      |      |
# | 5    | 27   | Y    | X    |      | X    |
# | 5    | 33   | N    | X    |      |      |
# | 6    | 24   | Y    | X    |      |      |
# | 7    | END  | Y    | X    |      |      |
# |------|------|------|------|------|------|
#
#
# The function 'bar' is inline within 'main' while 'foo' is not
# inline.  Function 'foo' is called from 'main' immediately after the
# inlined call to bar.  The C code can be found in
# dw2-inline-bt-src.c.  The line table is similar to that generated by
# compiling the source code at optimisation level -Og.
#
# Place a breakpoint in 'foo', run to the breakpoint, and then examine
# frame #1, that is, the frame for 'main'.  At one point, buts in GDB
# meant that the user would be shown the inline line from 'bar' rather
# than the line from 'main'.  In the example above the user expects to
# see line 33 from 'main', but instead would be shown line '27'.
#
# The cause of the bug is this: to find the line for frame #1 GDB
# first finds an address in frame #1 by unwinding frame #0.  This
# provides the return address in frame #1.  GDB subtracts 1 from this
# address and looks for a line matching this address.  In this case
# that would be line 33.
#
# However, GDB would then scan backward through the line table looking
# for a line table entry that is marked as is-stmt.  In this case, the
# first matching entry is that for line 27, and so that is what is
# reported.
#
# This has now been fixed to prevent the backward scan for frames
# other than frame #0.
#
# The source for this test is split over two files.  The -lbls.c file
# defines the structure of the test with labels added.  This is the
# file that actually gets compiled and run, the labels are used by
# this script for building the line table and other DWARF info.
#
# The -src.c file is only ever referenced by the debug information.
# This is the file that the line table points too.  The source code in
# this file does represent the issue in question, I originally
# compiled this file (at -Og to reproduce the bug) and the DWARF
# generated by this script is based on the debug information I saw in
# from that compiled file.

load_lib dwarf.exp

# This test can only be run on targets which support DWARF-2 and use
# gas.
require dwarf2_support

standard_testfile -lbls.c -src.c -asm.S

# Find lines so we can build the line table.
set call_line [gdb_get_line_number "call line" $srcfile2]
set foo_prologue [gdb_get_line_number "foo prologue" $srcfile2]
set main_prologue [gdb_get_line_number "main prologue" $srcfile2]
set bar_body [gdb_get_line_number "bar body" $srcfile2]

set build_options {nodebug}

# Prepare and run the test.  Placed into a proc in case we ever want
# to parameterise this test in the future.

proc do_test { } {
    global srcfile srcfile2 srcfile3 srcfile4 testfile
    global call_line foo_prologue main_prologue bar_body

    set asm_file [standard_output_file $srcfile3]
    Dwarf::assemble $asm_file {
	global srcdir subdir srcfile srcfile2 srcfile3 testfile
	global call_line foo_prologue main_prologue bar_body

	declare_labels lines_label foo_label bar_label

	get_func_info main $::build_options
	get_func_info func $::build_options

	cu {} {
	    compile_unit {
		{producer "gcc" }
		{language @DW_LANG_C}
		{name ${srcfile2}}
		{low_pc 0 addr}
		{stmt_list ${lines_label} DW_FORM_sec_offset}
	    } {
		foo_label: subprogram {
		    {external 1 flag}
		    {name foo}
		    {low_pc $func_start addr}
		    {high_pc "$func_start + $func_len" addr}
		}
		bar_label: subprogram {
		    {external 1 flag}
		    {name bar}
		    {inline 3 data1}
		}
		subprogram {
		    {external 1 flag}
		    {name main}
		    {low_pc $main_start addr}
		    {high_pc "$main_start + $main_len" addr}
		} {
		    inlined_subroutine {
			{abstract_origin %$bar_label}
			{low_pc line_label_4 addr}
			{high_pc line_label_5 addr}
			{call_file 1 data1}
			{call_line $call_line data1}
		    }
		}
	    }
	}

	lines {version 2 default_is_stmt 1} lines_label {
	    include_dir "${srcdir}/${subdir}"
	    file_name "$srcfile2" 1

	    program {
		DW_LNE_set_address func
		line $foo_prologue
		DW_LNS_copy

		DW_LNE_set_address line_label_1
		DW_LNS_advance_line 1
		DW_LNS_copy

		DW_LNE_set_address line_label_2
		DW_LNS_advance_line 1
		DW_LNS_negate_stmt
		DW_LNS_copy

		DW_LNE_set_address main
		DW_LNS_advance_line [expr $main_prologue - $foo_prologue - 2]
		DW_LNS_negate_stmt
		DW_LNS_copy

		DW_LNE_set_address line_label_4
		DW_LNS_advance_line 1
		DW_LNS_copy

		DW_LNE_set_address line_label_4
		line $bar_body
		DW_LNS_copy

		DW_LNE_set_address line_label_4
		line $call_line
		DW_LNS_negate_stmt
		DW_LNS_copy

		# Skip line_label_5.

		DW_LNE_set_address line_label_6
		DW_LNS_advance_line 1
		DW_LNS_copy

		DW_LNE_set_address "$main_start + $main_len"
		DW_LNE_end_sequence
	    }
	}
    }

    if { [prepare_for_testing "failed to prepare" ${testfile} \
	      [list $srcfile $asm_file] $::build_options] } {
	return -1
    }

    if ![runto foo] {
	return -1
    }

    set foo_body [expr $foo_prologue + 1]
    gdb_test "bt" \
	[multi_line \
	     "^#0\\s+foo \\(\\) at \[^\r\n\]+$::srcfile2:(?:$foo_prologue|$foo_body)" \
	     "#1\\s+$::hex in main \\(\\) at \[^\r\n\]+$::srcfile2:$call_line"] \
	"backtrace show correct line number in main"

    gdb_test "frame 1" \
	[multi_line \
	     "^#1\\s+$::hex in main \\(\\) at \[^\r\n\]+$::srcfile2:$call_line" \
	     "$call_line\\s+foo \\(bar \\(\\)\\);\[^\r\n\]+"] \
	"correct lines are shown for frame 1"
}

# Run the test.
do_test
