# Copyright 2020-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test running an inferior with arguments.

# This does not work on boards that don't support inferior arguments.
require {!target_info exists noargs}

standard_testfile .c

if {[build_executable "failed to prepare" $testfile $srcfile \
	 {debug additional_flags=-std=c99}] == -1} {
    return
}

proc do_test { method startup_with_shell inferior_args expected_results } {
    global binfile hex

    clean_restart $binfile

    gdb_test_no_output "set startup-with-shell $startup_with_shell"

    if { $method == "start" } {
	# The start command does not make sense for a stub.
	if { [use_gdb_stub] } {
	    return;
	}

	if { [gdb_start_cmd $inferior_args] < 0 } {
	    fail "could not issue start command"
	    return -1
	}

	# Consume up to the GDB prompt after the stop.
	gdb_test "" ".*main.*" "stop at main"

    } elseif { $method == "starti" } {
	# The starti command does not make sense for a stub.
	if { [use_gdb_stub] } {
	    return;
	}

	if { [gdb_starti_cmd $inferior_args] < 0 } {
	    fail "could not issue start command"
	    return -1
	}

	# Consume up to the GDB prompt after the stop.
	gdb_test "" "" "stop at first instruction"

	# Put a breakpoint and continue until main.
	if { ![gdb_breakpoint "main" message] } {
	    fail "could not set breakpoint on main"
	    return -1
	}

	if { [gdb_continue "main"] != 0 } {
	    fail "could not continue to main"
	    return -1
	}

    } elseif { $method == "run" } {
	if { ![gdb_breakpoint "main" message] } {
	    fail "could not set breakpoint on main"
	    return -1
	}

	# The run command does not make sense for a stub, but GDB_RUN_CMD
	# does the right thing when the target is a stub (start the stub,
	# connect to it, and "continue").
	#
	# This allows us to test arguments passed on the gdbserver command
	# line.
	if { [gdb_run_cmd $inferior_args] < 0 } {
	    fail "could not run"
	    return -1
	}

	# Consume up to the GDB prompt after the stop.
	gdb_test "" ".*main.*" "stop at main"

    } elseif { $method == "set args" } {
	# Using "set args" does not make sense with a stub.
	if { [use_gdb_stub] } {
	    return;
	}

	## gdb_test_no_output "set args $inferior_args"
	gdb_test "set args $inferior_args" ".*"

	if { ![runto_main] } {
	    return -1
	}

    } else {
	error "invalid method $method"
    }

    set argc [expr [llength $expected_results] + 1]

    # Now that we are stopped at main, inspect argc/argv.
    gdb_test "print argc" " = $argc"
    gdb_test "print argv\[0\]" " = $hex \"\[^\r\n\]+\""
    for { set i 1 } { $i < $argc } { incr i } {
	set idx [expr $i - 1]
	verbose -log "ZZZ($i): Looking for: = [lindex $expected_results $idx]"
	gdb_test "print argv\[$i\]" " = [lindex $expected_results $idx]"
    }
}

set startup_with_shell_modes { "on" }
if {!([target_info gdb_protocol] == "remote"
       || [target_info gdb_protocol] == "extended-remote")} {
    lappend startup_with_shell_modes "off"
} else {
    # Due to PR gdb/28392 gdbserver doesn't currently support having
    # startup-with-shell off, and then attempting to pass arguments
    # containing whitespace.
    ## unsupported "bug gdb/28392: gdbserver doesn't support this"
    lappend startup_with_shell_modes "off"
}

set test_desc_list []

# test one
# --------
#
# The second arg is an empty string on purpose.  The last argument
# must be the empty argument -- we once had a bug where that wouldn't
# work!
lappend test_desc_list [list "test one" \
			    { "first arg" "" "third-arg" "'" "\"" " " "" } \
			    [list "$hex \"first arg\"" \
				 "$hex \"\"" \
				 "$hex \"third-arg\"" \
				 "$hex \"'\"" \
				 "$hex \"\\\\\"\"" \
				 "$hex \" \"" \
				 "$hex \"\"" ]]

#
# test two
# --------
#
# The argument being passed here is '"', that is a single double quote
# contained within single quotes.
#
# I build the test descriptor using this mess of code to avoid having
# unbalanced quotes, which messes up indentation and syntax
# highlighting within (at least) emacs.  The 'format' of ascii code 34
# gives us the double quote character.  Then I have to jump through
# the rest of this mess in order to avoid TCL escaping the quote for
# me.  It's super important that what we send to GDB is '"' not '\"'.
set item [list "test two"]
set cmd [format "lappend item \{ '%c' '\\%c' \}" 34 34]
eval $cmd
set bs "\\\\"
lappend item [list "$hex \"$bs\"\"" "$hex \"$bs$bs$bs\"\""]
lappend test_desc_list $item

foreach desc $test_desc_list {
    lassign $desc name args re_list
    with_test_prefix $name {
	foreach_with_prefix method_ { "start" "starti" "run" "set args" } {
	    foreach_with_prefix startup_with_shell $startup_with_shell_modes {
		do_test $method_ $startup_with_shell $args $re_list
	    }
	}
    }
}
