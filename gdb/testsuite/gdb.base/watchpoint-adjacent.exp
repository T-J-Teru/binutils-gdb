# Copyright 2025 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# The inferior has two adjacent variables.  This test is about
# creating different types of watchpoint that cover both of the
# adjacent variables, and checking that GDB stops at the correct
# watchpoint.
#
# Multiple test programs are compiled, using a variety of types for
# the two variables.
#
# The two variables are placed adjacent to each other, and the
# variables, as a pair are placed at an 8-byte boundary.  Some
# architectures (e.g. AArch64) can only watch a memory region starting
# at an 8-byte boundary, so for small variable types each variables
# watchpoint will end up covering the same 8-byte region, GDB then has
# to choose between multiple watchpoints when a watchpoint hit occurs.

require allow_hw_watchpoint_tests

standard_testfile

# When printing a value, for some variable types, GDB will add a
# suffix containing an alternative representation of the value.  For
# example, characters will be printed as decimal, and then as the
# character.
#
# Return a regexp to match the suffix for a variable of VAR_TYPE.
# This doesn't match the specific value contents, it will match all
# possible suffix values for something of VAR_TYPE.
proc get_value_suffix { var_type } {
    if { $var_type eq "char" } {
	set suffix " '\[^'\]+'"
    } else {
	set suffix ""
    }

    return $suffix
}

# Start BINFILE, then set a watch and rwatch watchpoint on WATCH_VAR
# and RWATCH_VAR respectively.  Continue the inferior and expect to
# see GDB stop due to WATCH_VAR being written too.
proc run_write_test { binfile var_type watch_var rwatch_var } {
    clean_restart $binfile

    if { ![runto_main] } {
	return
    }

    gdb_test "watch obj.$watch_var" \
	"Hardware watchpoint $::decimal: obj.$watch_var"
    set wp_num [get_integer_valueof "\$bpnum" "*UNKNOWN*"]
    gdb_test "rwatch obj.$rwatch_var" \
	"Hardware read watchpoint $::decimal: obj.$rwatch_var"

    if { $watch_var eq "a" } {
	set new_val 1
    } else {
	set new_val 2
    }

    set suffix [get_value_suffix $var_type]

    gdb_test "continue" \
	[multi_line \
	     "Hardware watchpoint $wp_num: obj.$watch_var" \
	     "" \
	     "Old value = 0${suffix}" \
	     "New value = ${new_val}${suffix}" \
	     ".*"]

}

# Start BINFILE, continue until the call to the `reader` function in
# the inferior.  Then create an 'rwatch' watchpoint on RWATCH var,
# which will be either 'a' or 'b'.  Next create 'watch' watchpoints on
# both the 'a' and 'b' variables, watching for writes.
#
# Continue the inferior, both 'a' and 'b' are read, and GDB should stop
# and let us know that we stopped at the 'rwatch' watchpoint.
#
# On some architectures, for some variable sizes, the hardware cannot
# figure out which watchpoint triggered as the hardware can only watch
# (for example) 8-byte memory blocks.  In this case GDB just reports
# the first watchpoint (in creation order) within the block.  For this
# reason the test creates the 'rwatch' watchpoint first.
proc run_read_test { binfile var_type rwatch_var } {
    clean_restart $binfile

    if { ![runto_main] } {
	return
    }

    gdb_breakpoint [gdb_get_line_number "Break for read test"]
    gdb_continue_to_breakpoint "prepare for read test"

    gdb_test "rwatch obj.${rwatch_var}" \
	"Hardware read watchpoint $::decimal: obj.$rwatch_var"
    set wp_num [get_integer_valueof "\$bpnum" "*UNKNOWN*"]
    gdb_test "watch obj.a" \
	"Hardware watchpoint $::decimal: obj.a"
    gdb_test "watch obj.b" \
	"Hardware watchpoint $::decimal: obj.b"

    if { $rwatch_var eq "a" } {
	set val 1
    } else {
	set val 2
    }

    set suffix [get_value_suffix $var_type]

    gdb_test "continue" \
	[multi_line \
	     "Hardware read watchpoint ${wp_num}: obj.$rwatch_var" \
	     "" \
	     "Value = ${val}${suffix}" \
	     ".*"]
}

# Build a binary using VAR_TYPE as the test variable type.  Then Call
# run_test twice.
proc build_and_run_test { var_type } {
    set filename ${::testfile}-${var_type}
    set binfile [standard_output_file $filename]

    set flags [list debug additional_flags=-DVAR_TYPE=${var_type}]
    if {[build_executable "failed to build" $filename $::srcfile $flags]} {
	return
    }

    foreach_with_prefix var { a b } {
	run_read_test $binfile $var_type $var
    }

    foreach test { {a b} {b a} } {
	set watch_var [lindex $test 0]
	set rwatch_var [lindex $test 1]

	with_test_prefix "watch: ${watch_var}, rwatch: ${rwatch_var}" {
	    run_write_test $binfile $var_type $watch_var $rwatch_var
	}
    }
}

# Run the test with a series of different types.
foreach_with_prefix var_type { type_ll int short char float double } {
    build_and_run_test $var_type
}
