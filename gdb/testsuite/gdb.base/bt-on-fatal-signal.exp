# Copyright 2021 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test the 'maint set backtrace-on-fatal-signal' behaviour.  Start up
# GDB, turn on backtrace-on-fatal-signal, then send fatal signals to
# GDB and ensure we see the backtrace.

standard_testfile

if {[prepare_for_testing "failed to prepare" $testfile $srcfile]} {
    return -1
}

# Check we can run to main.  If this works this time then we just
# assume that it will work later on (when we repeatedly restart GDB).
if ![runto_main] then {
    untested $testfile
    return -1
}

# Check that the backtrace-on-fatal-signal feature is supported.  If
# this target doesn't have the backtrace function available then
# trying to turn this on will give an error, in which case we just
# skip this test.
gdb_test_multiple "maint set backtrace-on-fatal-signal on" "" {
    -re "support for this feature is not compiled into GDB" {
	untested $testfile
	return -1
    }
    -re "$gdb_prompt $" {
	pass $gdb_test_name
    }
}

# Now the actual test loop.
foreach test_data {{SEGV "Segmentation fault"} \
		       {FPE "Floating point exception"} \
		       {BUS "Bus error"} \
		       {ABRT "Aborted"}} {
    set sig [lindex ${test_data} 0]
    set msg [lindex ${test_data} 1]
    with_test_prefix ${sig} {

	# Restart GDB.
	clean_restart $binfile

	# Capture the pid of GDB.
	set testpid [spawn_id_get_pid $inferior_spawn_id]

	# Start the inferior.
	runto_main

	# Turn on the backtrace-on-fatal-signal feature.
	gdb_test_no_output "maint set backtrace-on-fatal-signal on"

	# Flags for various bits of the output we expect to see, we
	# check for these in the gdb_test_multiple below.
	set saw_fatal_msg False
	set saw_bt_start False
	set saw_bt_end False

	# Send the fatal signal to GDB.
	eval exec kill -${sig} ${testpid}

	# Scan GDB's output for the backtrace.
	gdb_test_multiple "" "scan for backtrace" {
	    -re "^\r\n" {
		exp_continue
	    }
	    -re "^Fatal signal: ${msg}\r\n" {
		set saw_fatal_msg True
		exp_continue
	    }
	    -re "^----- Backtrace -----\r\n" {
		set saw_bt_start True
		exp_continue
	    }
	    -re ".+\r\n---------------------\r\n" {
		set saw_bt_end True
		exp_continue
	    }
	    eof {
		# Catch the eof case as this indicates that GDB has
		# gone away, which in this case, is what we expect to
		# happen.
		gdb_assert { $saw_fatal_msg }
		gdb_assert { $saw_bt_start }
		gdb_assert { $saw_bt_end }
	    }
	    -re "$gdb_prompt $" {
		# GDB should terminate, we should never get back to
		# the prompt.
		fail $gdb_test_name
	    }
	}

	# GDB is now dead and gone.
    }
}
